Arquictura de N Capas:

Creamos repositorio en github
git clone https://github.com/JBEdix/backend-section.git
npm init


dependencias:
npm i express express-async-errors awilix cors compression helmet bcryptjs jsonwebtoken memory-cache mongoose swagger-ui-express mongoose-autopopulate

creamos un archivo .gitignore y en ella ponemos node_modules para que no se cargue en el repositorio.

npm i -D dotenv nodemon mockingoose jest //jest para test para api

creamos index.js

en package.json incluimos un scritp:
    "start":"node index.js",//npm start // para produccion
    "dev":"nodemon index.js",// npm run dev // para desarrollo

creamos las carpetas tests, src/controllers, src/models, src/services, src/routes, src/middlewares, src/repositories, src/helpers, src/startup, src/config en cada una de las subcarpetas de src debe haber un index.js

Se hizo commit con un gad ADD:"" y pull.
-----------------------------------------------------------------------------
Crear archivo .env:
    touch .env
en dicho archivo configuramos variables de entorno (Este archivo no deberia de estar en el git, se debe poner en el gitignore):
PORT=5050
MONGO_URI="mongodb+srv://dbJB:7vteUYhvernRe9y@cluster0-yovst.azure.mongodb.net/shareyouridea?retryWrites=true&w=majority"
APPLICATION_NAME="Share Your Idea"

en src/config/index.js
if (proccess.env.NODE_ENV !== "production"){
    require("dotenv").config();
}

module.exports={
    PORT: process.env.PORT,
    MONGO_URI: proccess.env.MONGO_URI,
    APPLICATION_NAME: proccess.env.APPLICATION_NAME
}

en src/startup/container.js
const { createContainer, asClass, asValue, asFunction } =require('awilix');// asclasss/value/funtion inyecta un objeto como una clase, valor o funcion

const container= createContainer();

module.exports= container;

en src/services/home.service.js
    class HomeServive{
        index(){
        return{
            message:"hello world"
        };
        }
    }

    module.exports = HomeServive;

en src/services/index.js
    module.exports = {
        HomeService: require("./home.service")
    }

en src/startup/container.js

    const { createContainer, asClass, asValue, asFunction } = require('awilix');// asclasss/value/funtion inyecta un objeto como una clase, valor o funcion

    //Services
    const { HomeService } = require('../services')

    const container= createContainer();

    container.register({
        HomeService: asClass(HomeService).singleton()
    });

    module.exports = container;


en controllers/home.controller.js:
    let _homeService = null;

    class HomeController{
        constructor ({HomeService}){
            _homeService = HomeService;
        }
        index(req, res){
            return res.send(_homeService.index())
        }

    }

    module.exports = HomeController;

importamos en controllers/index.js:
module.exports = {
    HomeController: require('./home.controller')
}

en startup/container.js:
    const { createContainer, asClass, asValue, asFunction } = require('awilix');// asclasss/value/funtion inyecta un objeto como una clase, valor o funcion
    //Services
    const { HomeService } = require('../services')
    //controller
    const { HomeController } =require('../controllers')

    const container= createContainer();
    container.register({
        HomeService: asClass(HomeService).singleton()
    }).register({
        HomeController: asClass(HomeController.bind(HomeController)).singleton()
    });

    module.exports = container;

en routes/index.routes.js:
    module.exports = {
        HomeRoutes: require('./home.routes')
    }

en routes/home.routes.js:
    const { Router } = require('express');
    module.exports = function({HomeController}){
        const router = Router();
        router.get("/", HomeController.index);
        return router;
    };

en startup/container.js agregamos:
    //routes
    const { HomeRoutes } = require('../routes/index.routes');
    y un nuevo registro en la variable container
    .register({
        HomeRoutes: asFunction(HomeRoutes).singleton()
    });

en routes/index.js:
const express = require('express');
const cors = require('cors');
const helmet = require('helmet');
const compression = require('compression');
require("express-async-errors");

module.exports = function({HomeRoutes}){
    const router = express.Router();
    const apiRoutes = express.Router();

    apiRoutes.use(express.json()).use(cors()).use(helmet()).use(compression());
    apiRoutes.use("/home", HomeRoutes);
    router.use("/v1/api", apiRoutes);

    return router
};

en startup/container.js:
en el apartado de //routes
const Routes = require('../routes');

//config
    const config = require('../config');

    agregamos otro registro:
    .register({
        router: asFunction(Routes).singleton(),
        config: asValue(config)
    })

    en startup/index.js:
    const express = require('express');

    let _express = null;
    let _config = null;

    class Server{
        constructor({config, router}){
            _config= config;
            _express = express().use(router);
        }

        start(){
            return new Promise(resolve => {
                _express.listen(_config.PORT, ()=>{
                    console.log(_config.APPLICATION_NAME + "API running on port" + _config.PORT);
                    resolve();
                });
            });
        }
    }

    module.exports = Server;

en startup/container:
    en el apartado de //config
    const app = require('.');
    y agregamos en el registro donde tenemos los atributos de router, config uno nuevo:
    app: asClass(app).singleton()

en index.js principal:
const container = require('./src/startup/container');
const server = container.resolve("app");
const { MONGO_URI } = container.resolve("config");

const mongoose = require('mongoose');
mongoose.set("useCreateIndex", true);

mongoose
.connect(MONGO_URI, { useNewUrlParser: true, useFindAndModify: false, useUnifiedTopology: true})
.then(()=>server.start())
.catch(console.log);

Arreglar error de rutas no encontradas y errores:
en src/middlewares:
    /not-found.middleware.js:
    module.exports = (req, res, next) => res.status(404).send({status:404, message:"Resource not found"});
    /error.middlewares.js:
    module.exports = (err, req, res, next) => {
        const httpStatus = err.status || 500;
    
        return res.status(httpStatus).send({
            status: httpStatus,
            message: err.message || "Internal server error"
        });
    };

    en middlewares.index.js
    module.exports = {
        NotFoundMiddleware: require("./not-found.middleware"),
        ErrorMiddleware: require("./error.middleware")
    }

    en routes/index.js:
    importamos:
    const { NotFoundMiddleware, ErrorMiddleware } = require('../middlewares');
    y agregamos abajo de las rutas establecidas:
    router.use(NotFoundMiddleware);
    router.use(ErrorMiddleware);

luego se hace commit y pull en el branch principal
----------------------------------------------------------------------------------------------------

Creacion de modelos:
en models
user.models.js:
    const mongoose = require('mongoose');
    const { Schema } = mongoose;
    const { compareSync, hashSync, genSaltSync } = require("bcryptjs");

    const UserSchema = new Schema({
        name: {type: String, required:true},
        username: {type: String, required:true},
        password: { type: String, required: true},
        age: {type: Number, required:true}
    });

    UserSchema.methods.toJSON = function(){
        let user = this.toObject();
        delete user.password;
        return user;
    };

    UserSchema.methods.comparePasswords = function (){
        return compareSync(password, this.password);
    };

    UserSchema.pre('save', async function(next){
        const user = this;

        if(!user.isModified("password")){
            return next();
        }

        const salt = genSaltSync(10);//10 => es la longitud de 10 caracteres
        const hashedPassword = hashSync(user.password, salt);
        user.password = hashedPassword;
        next();
    });


    module.exports = mongoose.model("user", UserSchema);

en idea.model.js:
    const mongoose = require('mongoose');
    const { Schema } = mongoose;

    const IdeaSchema = new Schema({
        idea: {type: String, required:true},
        description: {type: String},
        upvotes:[{type: Boolean}],
        downvotes: [{type: Boolean}],
        author: {type: Schema.Types.ObjectId, ref: "user", required:true, autopopulate: true}, 
        comments:[{type: Schema.Types.ObjectId, ref: "comment", required:true, autopopulate: true}]
    });

    IdeaSchema.plugin(require('mongoose-autopopulate'));

    module.exports = mongoose.model("idea", IdeaSchema);

en comment.model.js:
    const mongoose = require('mongoose');
    const { Schema } = mongoose;

    const CommentSchema = new Schema({
        comment: {type: String, required:true},
        description: {type: String},
        author: {type: Schema.Types.ObjectId, ref: "user", required:true, autopopulate: true}
    });

    CommentSchema.plugin(require('mongoose-autopopulate'));

    module.exports = mongoose.model("comment", CommentSchema);

en models/index.js:
    module.exports = {
        User: require('./user.model'),
        Idea: require('./idea.model'),
        Comment: require('./comment.model')
    }

en startup/container.js
Importamos los modelos:
//models
const {User, Comment, Idea} = require('../models');

Agregamos el registro para nuestros modelos:
.register({
    User: asValue(User),
    Comment: asValue(Comment),
    Idea: asValue(Idea)
});

----------------------------------------------------------------------------------------------------
Creacion de repositorio:
creamos en repositories:
base.repository.js:
class BaseRepository {
    constructor(model){
        this.model = model;
    }

    async get(id){
        return await this.model.findById(id);
    }
    async getAll(){
        return await this.model.find();
    }
    async create(entity){
        return await this.model.create(entity);
    }
    async update(id, entity){
        return await this.model.findByIdAndUpdate(id, entity, {new: true});
    }
    async delete(id){
        await this.model.findByIdAndDelete(id);
        return true;
    }
}

module.exports = BaseRepository;

/user.repository.js:
const BaseRepository = require('./base.repository');
let _user = null;

class UserRepository extends BaseRepository {
    constructor({ user }){
        super(user);
        _user = user;
    }
    async getUserByUserName(userName){
        return await _user.findOne({userName});
    }

}

module.exports = UserRepository;

/idea.repository.js:
const BaseRepository = require('./base.repository');
let _idea = null;

class IdeaRepository extends BaseRepository {
    constructor({ idea }){
        super(idea);
        _idea = idea;
    }

    async getUserIdeas(author){
        return await _idea.find({author});
    }
}

module.exports = IdeaRepository;

/comment.repository.js:
const BaseRepository = require('./base.repository');
let _comment= null;

class CommentRepository extends BaseRepository {
    constructor({ comment }){
        super(comment);
        _comment = comment;
    }
}

module.exports = CommentRepository;

en repositories/index.js:
module.exports = {
    UserRepository: require('./user.repository'),
    IdeaRepository: require('./idea.repository'),
    CommentRepository: require('./comment.repository')
}

en el contenedor /startup/container.js:
importamos los repositorios:
//Repositories
const {CommentRepository, IdeaRepository, UserRepository} = require('../repositories');
y agregamos los registros:
.register({
    CommentRepository: asClass(CommentRepository).singleton(), 
    IdeaRepository: asClass(IdeaRepository).singleton(),
    UserRepository: asClass(UserRepository).singleton()
});
[ADD] Repositories added
-----------------------------------------------------------------------------------------------------

Creacion de microservicios:

en service/base.service.js:
    class BaseService{
        constructor(repository){
            this.repository = repository;
        }
        async get(id){
            if(!id){
                const error = new Error();
                error.status = 404;
                error.message = "id must be sent";
                throw error;
            }
            
            const currentEntity = await this.repository.get(id);
            if(!currentEntity){
                const error = new Error();
                error.status = 404;
                error.message = "entity does not found";
                throw error;
            }
            return currentEntity;
        }
        
        async getAll(){
            return await this.repository.getAll();
        }

        async create(entity){
            return await this.repository.create(entity);
        }

        async update(id, entity){
            if(!id){
                const error = new Error();
                error.status = 404;
                error.message = "id must be sent";
                throw error;
            }
            return await this.repository.update(id, entity);
        }

        async delete(id){
            if(!id){
                const error = new Error();
                error.status = 404;
                error.message = "id must be sent";
                throw error;
            }
            return await this.repository.delete(id);
        }
    }

    module.exports = BaseService;

en user.service.js:
    const BaseService = require('./base.service');
    let _userRepository = null;

    class UserService extends BaseService{
        constructor({UserRepository}){
            super(UserRepository);
            _userRepository = UserRepository;
        }

        async getUserByUserName(userName){
            return await _userRepository.getUserByUserName(userName);
        }
    }

    module.exports = UserService;

en idea.service.js:
    const BaseService = require('./base.service');
    let _ideaRepository = null;

    class IdeaService extends BaseService{
        constructor({IdeaRepository}){
            super(IdeaRepository);
            _ideaRepository = IdeaRepository;
        }

        async getUserIdeas(author){
            if(!author){
                const error = new Error();
                error.status = 400;
                error.message = "UserId must be sent";
                throw error;
            }
            return await _ideaRepository.getUserIdeas(author);
        }

        async upvoteIdea(ideaId){
            if(!ideaId){
                const error = new Error();
                error.status = 400;
                error.message = "IdeaId must be sent";
                throw error;
            }

            const idea = await _ideaRepository.get(ideaId);
            if (!idea){
                const error = new Error();
                error.status = 404;
                error.message = "idea does not exist";
                throw error;
            }

            idea.upvotes.push(true);

            return await _ideaRepository.update(ideaId, {upvotes: idea.upvotes});
        }

        async downvoteIdea(ideaId){
            if(!ideaId){
                const error = new Error();
                error.status = 400;
                error.message = "IdeaId must be sent";
                throw error;
            }

            const idea = await _ideaRepository.get(ideaId);
            if (!idea){
                const error = new Error();
                error.status = 404;
                error.message = "idea does not exist";
                throw error;
            }

            idea.downvotes.push(true);
            
            return await _ideaRepository.update(ideaId, {downvotes: idea.downvotes});
        }
    }

    module.exports = IdeaService;

en comment.service.js:
    const BaseService = require('./base.service');
    let _commentRepository = null;
    let _ideaRepository = null;

    class CommentService extends BaseService{
        constructor({CommentRepository, IdeaRepository}){
            super(CommentRepository);
            _commentRepository = CommentRepository;
            _ideaRepository = IdeaRepository;
        }

        async getIdeaComment(ideaId){
            if (!ideaId){
                const error = new Error();
                error.status = 400;
                error.message = "ideaId must be sent";
                throw error;
            }
            const idea = await _ideaRepository.get(ideaId);
            if (!idea){
                const error = new Error();
                error.status = 404;
                error.message = "idea does not exist";
                throw error;
            }

            const { comments } = idea;
            return comments;
        }

        async createComment(commnent, ideaId, , userId){
            if (!ideaId){
                const error = new Error();
                error.status = 400;
                error.message = "ideaId must be sent";
                throw error;
            }
            const idea = await _ideaRepository.get(ideaId);
            if (!idea){
                const error = new Error();
                error.status = 404;
                error.message = "idea does not exist";
                throw error;
            }

            const createdComment = await _commentRepository.create({...commnent, author: userId});
            idea.comments.push(createdComment); 

            return await _ideaRepository.update(ideaId, {comments: idea.comments});
        }
    }

    module.exports = CommentService;

en service/index.js:
    module.exports = {
        HomeService: require("./home.service"),
        UserService: require('./user.service'),
        IdeaService: require('./idea.service'),
        CommentService: require('./comment.service')
    }

en el contenedor:
importamos donde ya teniamos el sevicio de home:
    UserService, IdeaService, CommentService

    Agregamos los registros de los servicios donde ya teniamos el sevicio de homeService:
    UserService: asClass(UserService).singleton(), 
    IdeaService: asClass(IdeaService).singleton(), 
    CommentService: asClass(CommentService).singleton() 
-----------------------------------------------------------------------------------------------------

Creacion de los controladores:
en user.controller.js:
    let _userService = null;

    class UserController{
        constructor({UserService}){
            _userService = UserService
        }

        async get(req, res){
            const { userId } = req.params;
            const user = await _userService.get(userId);
            return res.send(user);
        }

        async getAll(req, res){
            const users = await _userService.getAll();
            return res.send(users);
        }

        async update(req, res){
            const { body } = req;
            const { userId } = req.params;
            const  updateUser =  await _userService.update(userId, body);
            return res.send(updateUser);
        }

        async delete(req, res){
            const { userId } = req.params;
            const deleteUser = await _userService.delete(userId);
            return res.send(deleteUser);
        }
    }

    module.exports = UserController;

en idea.controller.js:
    let _ideaService = null;

    class IdeaController{
        constructor({IdeaService}){
            _ideaService = IdeaService
        }

        async get(req, res){
            const { ideaId } = req.params;
            const idea = await _ideaService.get(ideaId);
            return res.send(idea);
        }

        async getAll(req, res){
            const ideas = await _ideaService.getAll();
            return res.send(ideas);
        }

        async create(req, res){
            const { body } = req;
            const createIdea = await _ideaService.create(body);
            return res.status(201).send(createIdea);
        }

        async update(req, res){
            const { body } = req;
            const { ideaId } = req.params;
            const  updateIdeas =  await _ideaService.update(ideaId, body);
            return res.send(updateIdeas);
        }

        async delete(req, res){
            const { ideaId } = req.params;
            const deleteIdeas = await _ideaService.delete(ideaId);
            return res.send(deleteIdeas);
        }

        async getUserIdeas(req, res){
            const {userId} = req.params;
            const ideas = await _ideaService.getUserIdeas(userId);
            return res.send(ideas);
        }

        async upvoteIdea(req, res){
            const {ideaId} = req.params;
            const idea = await _ideaService.upvoteIdea(ideaId);
            return res.send(idea);
        }

        async downvoteIdea(req, res){
            const {ideaId} = req.params;
            const idea = await _ideaService.downvoteIdea(ideaId);
            return res.send(idea);
        }
    }

    module.exports = IdeaController;

en comment.controller.js
    let _commentService = null;

    class CommentController{
        constructor({CommentService}){
            _commentService = CommentService
        }

        async get(req, res){
            const { commentId } = req.params;
            const comment = await _commentService.get(commentId);
            return res.send(comment);
        }

        async update(req, res){
            const { body } = req;
            const { commentId } = req.params;
            const  updateComment =  await _commentService.update(commentId, body);
            return res.send(updateComment);
        }

        async delete(req, res){
            const { commentId } = req.params;
            const deleteComment = await _commentService.delete(commentId);
            return res.send(deleteComment);
        }

        async getIdeaComment(req, res){
            const { ideaId } = req.params;
            const comments = await _commentService.getIdeaComment(ideaId);
            return res.send(comments);
        }

        async createComment(req, res){
            const { body } = req;
            const { ideaId } = req.params;
            const { id: userId } = req.user;
            const createComment = await _commentService.createComment(body, ideaId, userId);
            return res.send(createComment);
        }
    }

    module.exports = CommentController;

en controller/index.js:
    module.exports = {
        HomeController: require('./home.controller'), 
        UserController: require('./user.controller'),
        IdeaController: require('./idea.controller'),
        CommentController: require('./comment.controller')
    }

en el container:
importamos en el apartado de controladores:
    UserController, IdeaController, CommentController

Agregamos los registros de los controladores:
    UserController: asClass(UserController.bind(UserController)).singleton(),
    IdeaController: asClass(IdeaController.bind(IdeaController)).singleton(),
    CommentController: asClass(CommentController.bind(CommentController)).singleton(),

[ADD] controllers added
---------------------------------------------------------------------------------------------------

Creacion de rutas

en routes/
en user.routes.js
const { Router } = require('express');

module.exports = function({ UserController }){
    const router = Router();

    router.get("", UserController.getAll);
    router.get("/:userId", UserController.get);
    router.patch("/:userId", UserController.update);
    router.delete("/:userId", UserController.delete);
    
    return router;
}


en idea.routes.js:
const { Router } = require('express');

module.exports = function({ IdeaController }){
    const router = Router();

    router.get("", IdeaController.getAll);
    router.get("/:ideaId", IdeaController.get);
    router.get("/:ideaId/all", IdeaController.getUserIdeas);
    router.post("", IdeaController.create);
    router.patch("/:ideaId", IdeaController.update);
    router.delete("/:ideaId", IdeaController.delete);
    router.post("/:ideaId/upvote", IdeaController.upvoteIdea);
    router.post("/:ideaId/downvote", IdeaController.downvoteIdea);
    
    return router;
}

en commnent.routes.js:
const { Router } = require('express');

module.exports = function({ CommentController }){
    const router = Router();

    router.get("/:commentId/unique", CommentController.get);
    router.get("/:ideaId", CommentController.getIdeaComment);
    router.post("/:ideaId", CommentController.createComment);
    router.patch("/:commentId", CommentController.update);
    router.delete("/:commentId", CommentController.delete);
    
    return router;
}

en index.routes.js:
module.exports = {
    HomeRoutes: require('./home.routes'),
    UserRoutes: require('./user.routes'),
    IdeaRoutes: require('./idea.routes'),
    CommentRoutes: require('./comment.routes')
}

en el contenedor:
importamos las rutas en dicho apartado:
    , UserRoutes, IdeaRoutes, CommentRoutes 

y agregamos al registro para las rutas:
    UserRoutes: asFunction(UserRoutes).singleton(),
    IdeaRoutes: asFunction(IdeaRoutes).singleton(),
    CommentRoutes: asFunction(CommentRoutes).singleton(),

Por ultimo en index.js
inyectamos en el module.export: , UserRoutes, IdeaRoutes, CommentRoutes

y en agregamos las rutas abajo de la de home:
    apiRoutes.use("/user", UserRoutes);
    apiRoutes.use("/idea", IdeaRoutes);
    apiRoutes.use("/comment", CommentRoutes);

---------------------------------------------------------------------------------------------------
Autentificacion:

en config/index.js:
agregamos una variable de entorno
, JWT_SECRET: process.env.JWT_SECRET

en /.env:
JWT_SECRET=kjs34%^&@jdkJB

en helpers/jwt.helper.js:
    const {sign} = require('jsonwebtoken');
    const {JWT_SECRET} = require('../config');

    module.exports.generateToken = function(user){
        return sign ({user}, JWT_SECRET, {expiresIn:'1h'});
    };

en helper/index.js:
    module.exports = {
        JwtHelper: require('./jwt.helper')
    };

en services/auth.service.js:
const {generateToken} = require('../helpers/jwt.helper');
let _userService = null;

class AuthService{
    constructor({UserService}) {
        _userService = UserService;
    }

    async signUp(user){
        const {username} = user;
        const userExist = await _userService.getUserByUserName(username); //esto metodo viene del servicio user.service.js
        if (userExist){
            const error = new Error();
            error.status= 401;
            error.message = "User already exists";
            throw error;
        }
        return await _userService.create(user);
    }

    async signIn(user){
        const {username, password} = user;
        const userExist = await _userService.getUserByUserName(username); //esto metodo viene del servicio user.service.js
        if (!userExist){
            const error = new Error();
            error.status= 404;
            error.message = "User does not exists";
            throw error;
        }

        const validPassword = userExist.comparePasswords(password);
        if (!validPassword){
            const error = new Error();
            error.status= 400;
            error.message = "Invalid password";
            throw error;
        }

        const userToEncode = {
            username: userExist.username,
            id: userExist._id
        };

        const token = generateToken(userToEncode);

        return {token, user: userExist};
    }
}

module.exports = AuthService;

exportamos en el index.

en controllers/auth.controller.js:
    let _autService = null;

    class AuthController{
        constructor({AuthService}){
            _autService= AuthService;
        }

        async signUp(req, res){
            const {body} = req;
            const createdUser = await _autService.signUp(body);
            return res.status(201).send(createdUser);
        }

        async signIn(req, res){
            const {body} = req;
            const creds = await _autService.signIn(body);
            return res.send(creds);
        }
    }

    module.exports= AuthController;

Importamos en el index.

en routes/auth.routes.js
    const { Router } = require('express');

    module.exports = function({ AuthController }){
        const router = Router();

        router.post("/signup", AuthController.signUp);
        router.post("/signin", AuthController.signIn);
        
        return router;
    }

en routes/index.routes.js:
    AuthRoutes: require('./auth.routes')

importamos el servicio, el controlador y la ruta en el container:

en routes/index.js:
exportar en la clase AuthRoutes en el module.exports.

y creamos la ruta:
    apiRoutes.use("/auth", AuthRoutes);

para hacer un comprobacion de nuestra api:
Usando postman ponemos en la url: http://localhost:5050/v1/api/auth/signup [POST]
y en la pestanie de Body y la opcion de raw y en JSON:
{
	"name":"jheral2",
	"username":"JB2",
	"password":"asd.456",
	"age": 25
}

y lo podemos ver en mongo atlas o con la url: http://localhost:5050/v1/api/user [GET]
Nos deberias de mostrar el user creado.

y para obtener el token: http://localhost:5050/v1/api/auth/signin [POST]
{
	"username":"JB2",
	"password":"asd.456"
}

en middlewares/auth.middleware:
    const jwt = require('jsonwebtoken');
    const { JWT_SECRET } = require('../config');

    module.exports = function( req, res, next ){
        const token = req.headers["authorization"];
        if(!token){
            const error = new Error();
            error.status= 400;
            error.message= "Token must be sent";
            throw error;
        }

        jwt.verify(token, JWT_SECRET,function(err, decodedToken){
            if (err) {
                const error = new Error();
                error.status= 401;
                error.message= "Invalid token";
                throw error;
            }

            req.user = decodedToken.user;
            next();
        });
    }

lo importamos en el middlewares/index.js:
    ,AuthMiddleware: require('./auth.middleware')

Y en routes/user.routes.js:
lo importamos:const { AuthMiddleware } =require('../middlewares');

y lo agregamos como un arreglo o no en la ruta de obtener todos los usuarios
    router.get("", [AuthMiddleware], UserController.getAll);

volvemos a probar en con: http://localhost:5050/v1/api/user [GET]
Nos va a salir un:
{
    "status": 400,
    "message": "Token must be sent"
}

Por lo cual nuestro middleware esta funcionando. Esta protegido por un token.

Para ver todos los usuarios bien, debemos hacer un signIn con http://localhost:5050/v1/api/auth/signin [POST]
{
	"username":"JB2",
	"password":"asd.456"
}

Y luego copiar el token. En postman entramos en la pestania de headers que esta a la par de body:
en key: Authorization 
en Value: pegamos el token.

y nos muestra los usuarios.

----------------------------------------------------------------------------------------------------

Paginacion:

en middlewares/parse-int.middleware.js:
    module.exports = function(req, res, next){
        const queryStrings = req.query;

        //myapi.com?pageNum=5 esto viaja como un string. Debemos castearlo como un numero.
        for(const key in queryStrings){
            const length = queryStrings[key].length;
            const isValid = length > 20 ? false : !isNaN(parseInt(queryStrings[key]));
            //los id de mongo son caracteres mayores a 20, por lo cual la funcion que tenemos no los casteara.
            if (isValid) {
                queryStrings[key]= parseInt(queryStrings[key]);
            }
        }

        req.query = queryStrings;
        next(); //netx Da acceso al proximo middleware de la cola de express
    }

En middlewares/index.js:
    ,ParseIntMiddleware: require('./parse-int.middleware')

en repositories/base.repository.js:
    cambiamos el metodo de getAll:

    //* pageSize: limita la cantidad de recursos o elementos de una coleccion que queremos traer desde mongodb.
    //* pageNum: es la pagina que queremos saber.
    async getAll(pageSize = 5, pageNum = 1){//Esto retorna 5 elementos de la primera pagina.
        //* skip: Le dice a mongoose cuantos elementos debe saltar para comenzar a buscar.
        //* Limit: lilmita de cantidad de elemento que debe retornar.
        const skips = pageSize * (pageNum - 1);
        return await this.model.find().skip(skips).limit(pageSize);
    }

en services/base.service.js:
    async getAll(pageSize, pageNum){
        return await this.repository.getAll(pageSize, pageNum);
    }

en controllers/user.controller.js:
    async getAll(req, res){
        const { pageSize, pageNum } = req.query;
        const users = await _userService.getAll(pageSize, pageNum);
        return res.send(users);
    }

en controller/idea.controller.js:
    async getAll(req, res){
        const { pageSize, pageNum } = req.query;
        const ideas = await _ideaService.getAll(pageSize, pageNum);
        return res.send(ideas);
    }

en routes/user.routes.js:
importamos el middleware:
    const { AuthMiddleware, ParseIntMiddleware } = require('../middlewares');

Y lo inyectamos , ParseIntMiddleware en la ruta para ver todas los usuarios.

en routes/idea.routes.js:
lo importamos: 
    const { ParseIntMiddleware } = require('../middlewares');

y lo agregamos en la ruta de obtener todas las ideas:
    router.get("", ParseIntMiddleware, IdeaController.getAll)

Para comprobar esto. Agregamos varios usuarios y volvemos a generar:

volvemos a probar en con: http://localhost:5050/v1/api/user [GET] tener en cuenta lo del token del signIn.

podemos hacer un http://localhost:5050/v1/api/user?pageSize=7&pageNum=1 [GET] y nos tiene que generar 7 registros en vez de 5 como esta predeterminadamente.

para agregar una idea:
http://localhost:5050/v1/api/idea [POST]

{
    "idea":"Crear una app para compras en el super",
	"description":"App para llevar el control de las compras para la despensa",
	"author": "5eec1750d011fa05d83658c9"
}

para ver las ideas
http://localhost:5050/v1/api/idea [GET]
http://localhost:5050/v1/api/idea?pageSize=4&numPage=1 [GET]

-------------------------------------------------------------------------------------------------

Caching: Implementar la cache de la api:

en .env:
agregamos una variable de entorno
    CACHE_KEY=myCachePassword%asd.456

Lo adicionamos en el config/index.js:
    ,CACHE_KEY: process.env.CACHE_KEY

en middlewares/cache.middleware.js:
    const mcache = require('memory-cache');
    const { CACHE_KEY } = require('../config');

    module.exports=function(duration){
        return(req, res, next) =>{
            const key = CACHE_KEY + req.originUrl || req.url;
            const cachedBody = mcache.get(key);

            if (cachedBody) {
                return res.send(JSON.parse(cachedBody));
            } else{
                res.sendResponse = res.send;
                res.send = body => {
                    mcache.put(key, body, duration * 1000);
                    res.sendResponse(body);
                };
                next();
            }
        }
    }

en middlewares/index.js
    ,CacheMiddleware: require('./cache.middleware')

en helpers/cache-time.helper.js:
    module.exports={
        ONE_HOUR: 360
    }

en helpers/index.js:
    ,CACHE_TIME: require('./cache-time.helper')

en routes/user.routes.js:
importamos: 
    const { CACHE_TIME } = require('../helpers');

agregamos en donde tenemos los middlewares [AuthMiddleware, ParseIntMiddleware, CacheMiddleware(CACHE_TIME.ONE_HOUR)]

para probar haremos una peticion http://localhost:5050/v1/api/user [GET] teniendo en cuenta el token.

si vemos en la parte de time podemos ver el tiempo de ejecucion. si volvemos a hacer la peticion el tiempo disminuye significativa.

---------------------------------------------------------------------------------------------------

creamos en la carpeta principal de nuestro proyecto:
    jest.config.js:
        module.exports = {
            testEnvironment:"node"
        };

en tests/mocks/user/user.model.mock.js:
    module.exports = {
        usere: {
            _id: "507f191e810c19729de860ea",
            name: "Marluan",
            username: "Marluan03",
            password: "mystrongPassword"
        },
        users: [
            {
            _id: "507f191e810c19729de860ea",
            name: "Marluan",
            username: "Marluan03",
            password: "mystrongPassword"
            },
            {
            _id: "507f191e810c19729de860eb",
            name: "Erick",
            username: "Erick_34",
            password: "mystrongPassword"
            }
        ]
    };

en tests/mocks/user/userRepository.mock.js: aqui ponemos todas los metodos que tiene el User en el repository, tanto en base.repository como en el user.repository.

    module.exports = {
        get: jest.fn(),
        getAll: jest.fn(),
        create: jest.fn(),
        update: jest.fn(),
        delete: jest.fn(),
        getUserByUserName: jest.fn()
    };

en tests/mocks/index.js:
    module.exports = {
        UserModelMock: require("./user/user.model.mock"),
        UserRepositoryMock: require("./user/user.repository.mock")
    };

en test/unit/repositories:
    const { UserRepository } = require("../../../src/repositories");
    const mockingoose = require("mockingoose").default;
    const { user } = require("../../../src/models");
    let {
    UserModelMock: { usere, users }
    } = require("../../mocks");

    describe("user Repository", () => {
    beforeEach(() => {
        mockingoose.resetAll();
        jest.clearAllMocks();
    });
    
    //estos son los tests:
    it("Should find a user by id", async () => {
        const _user = { ...usere };
        delete _user.password;
        mockingoose(user).toReturn(usere, "findOne");

        const _userRepository = new UserRepository({ user });
        const expected = await _userRepository.get(_user._id);

        expect(JSON.parse(JSON.stringify(expected))).toMatchObject(_user);
    });

    it("Should find a user by username", async () => {
        const _user = { ...usere };
        delete _user.password;
        mockingoose(user).toReturn(usere, "findOne");

        const _userRepository = new UserRepository({ user });
        const expected = await _userRepository.getUserByUserName(_user.username);

        expect(JSON.parse(JSON.stringify(expected))).toMatchObject(_user);
    });

    it("Should return a usere collection", async () => {
        users = users.map(usere => {
        delete usere.password;
        return usere;
        });

        mockingoose(user).toReturn(users, "find");

        const _userRepository = new UserRepository({ user });
        const expected = await _userRepository.getAll();
        expect(JSON.parse(JSON.stringify(expected))).toMatchObject(users);
    });

    it("Should update an especific usere by id", async () => {
        const _user = { ...usere };
        delete _user.password;
        mockingoose(user).toReturn(_user, "findOneAndUpdate");
        const _userRepository = new UserRepository({ user });
        const expected = await _userRepository.update(usere._id, {
        name: "Marluan"
        });

        expect(JSON.parse(JSON.stringify(expected))).toMatchObject(_user);
    });

    it("Should delete an especific usere by id", async () => {
        mockingoose(user).toReturn(usere, "findOneAndDelete");
        const _userRepository = new UserRepository({ user });
        const expected = await _userRepository.delete(usere._id);
        expect(JSON.parse(JSON.stringify(expected))).toEqual(true);
    });
    });


para testear vamos a package.json:
en el apartado de test cambiamos lo que dice del echo... y ponemos jest


en test/unit/services:
    const { UserService } = require("../../../src/services");
    const { UserRepositoryMock } = require("../../mocks");
    const {
    UserModelMock: { usere, users }
    } = require("../../mocks");

    describe("User Service", () => {
    beforeEach(() => {
        jest.clearAllMocks();
    });

    /*it("Should find a usere by id", async () => {
        const UserRepository = UserRepositoryMock;
        UserRepository.get.mockReturnValue(usere);

        const _userService = new UserService({ UserRepository });
        const expected = await _userService.get(usere._id);
        expect(expected).toMatchObject(usere);
    });*/

    it("Should find a usere by username", async () => {
        const UserRepository = UserRepositoryMock;
        UserRepository.getUserByUserName.mockReturnValue(usere);

        const _userService = new UserService({ UserRepository });
        const expected = await _userService.getUserByUserName(usere.username);
        expect(expected).toMatchObject(usere);
    });

    it("Should return a usere collection", async () => {
        const UserRepository = UserRepositoryMock;
        UserRepository.getAll.mockReturnValue(users);

        const _userService = new UserService({ UserRepository });
        const expected = await _userService.getAll();
        expect(expected).toMatchObject(users);
    });

    it("Should update a usere by id", async () => {
        const UserRepository = UserRepositoryMock;
        UserRepository.update.mockReturnValue(usere);

        const _userService = new UserService({ UserRepository });
        const expected = await _userService.repository.update(usere._id, usere);
        expect(expected).toMatchObject(usere);
    });

    it("Should delete a usere by id", async () => {
        const UserRepository = UserRepositoryMock;
        UserRepository.delete.mockReturnValue(true);

        const _userService = new UserService({ UserRepository });

        const expected = await _userService.repository.delete(usere._id);
        expect(expected).toEqual(true);
    });
    });

para hacer el testeo debemos usar la terminal: npm test
------------------------------------------------------------------------------------------

Swagger: para la documentacion

Hay que usar un programa para crear un json de todo nuestro proyecto. que genere todo esto de forma automatica

tenemos dos json en /src/config/swagger/:
swaggerDEV.json y swaggerPROD

en .env creamos una nueva variable de entorno:
    SAGGER_DOC=swaggerDEV

la exportamos en el index.js de config:
    SAGGER_PATH: `../config/swagger/${process.env.SAGGER_DOC}.json`

Agregamos la ruta en routes/index.js:
    importamos el swagger:
    const swaggerUI = require('swagger-ui-express');
    const { SAGGER_PATH } = require('../config');
    const swaggerDocument = require(SAGGER_PATH);

    creamos la ruta:
    router.use("/api-docs", swaggerUI.serve, swaggerUI.setup(swaggerDocument));
    
--------------------------------------------------------------------------------------

Haciendo uso de nuestra api:
USER:
-------
Traer todos los usuarios:
http://localhost:5050/v1/api/user/ [GET]

Traer un user en especifico:
http://localhost:5050/v1/api/user/5eec16ecd011fa05d83658c4 [GET]

Actualizar usuario: tener token de auth:
http://localhost:5050/v1/api/user/5eec16ecd011fa05d83658c4 [PATH]
{
    "name": "Jheral Blanco"	
}

eliminar usuario: tener token de auth
http://localhost:5050/v1/api/user/5eec16ecd011fa05d83658c4 [DELETE]


IDEA:
-------
Obtener todas las ideas:
http://localhost:5050/v1/api/idea/ [GET]

traer una idea en especifico:
http://localhost:5050/v1/api/idea/5eec1b3ad011fa05d83658ca [GET]

Votar por una idea: tener token de auth
http://localhost:5050/v1/api/idea/5eec1b3ad011fa05d83658ca/upvote [POST]

DownVote por una idea: tener token de auth
http://localhost:5050/v1/api/idea/5eec1b3ad011fa05d83658ca/downvote [POST]

Actualizar la ideas: tener token de auth
http://localhost:5050/v1/api/idea/5eec1b3ad011fa05d83658ca [PACT]
{
	"description": "App para llevar el control de las compras de la casa para la despensa. x2"
}

crear idea: token
http://localhost:5050/v1/api/idea/ [POST]
{
    "idea": "Idea numero 2",
    "description": "descripcion de la idea 2",
    "author": "5eebefd582af010f6c784be5"
}

Eliminar idea: Token
http://localhost:5050/v1/api/idea/5eefeeb1243b8a13c4b6acb4 [DELETE]

Ver las ideas de un user en especifico: token
http://localhost:5050/v1/api/idea/5eebefd582af010f6c784be5/all

Comment:
-------

Crear comentarion:
http://localhost:5050/v1/api/comment/5eec1b3ad011fa05d83658ca [POST]
{
    "comment":"Good idea",
    "description":"asd.456"
}

para obtenet por un comentario en especifico:
http://localhost:5050/v1/api/comment/5eeffae4a8ac141be80c9804/unique [GET]

Obtener los comentarios de una idea en especifico: 
http://localhost:5050/v1/api/comment/5eec1b3ad011fa05d83658ca [GET]

actualizar un comentario: token
http://localhost:5050/v1/api/comment/5ef01198a8ac141be80c9806 [PATH]
{
    "comment":"Good idea x2",
    "description":"descripcion del comentarios. asd.456"
}

borrar un comentario: token
http://localhost:5050/v1/api/comment/5ef01198a8ac141be80c9806 [DELTE]

