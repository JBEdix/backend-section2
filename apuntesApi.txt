Arquictura de N Capas:

Creamos repositorio en github
git clone https://github.com/JBEdix/backend-section.git
npm init


dependencias:
npm i express express-async-errors awilix cors compression helmet bcryptjs jsonwebtoken memory-cache mongoose swagger-ui-express mongoose-autopopulate

creamos un archivo .gitignore y en ella ponemos node_modules para que no se cargue en el repositorio.

npm i -D dotenv nodemon mockingoose jest //jest para test para api

creamos index.js

en package.json incluimos un scritp:
    "start":"node index.js",//npm start // para produccion
    "dev":"nodemon index.js",// npm run dev // para desarrollo

creamos las carpetas tests, src/controllers, src/models, src/services, src/routes, src/middlewares, src/repositories, src/helpers, src/startup, src/config en cada una de las subcarpetas de src debe haber un index.js

Se hizo commit con un gad ADD:"" y pull.
-----------------------------------------------------------------------------
Crear archivo .env:
    touch .env
en dicho archivo configuramos variables de entorno:
PORT=5050
MONGO_URI="mongodb+srv://dbJB:7vteUYhvernRe9y@cluster0-yovst.azure.mongodb.net/shareyouridea?retryWrites=true&w=majority"
APPLICATION_NAME="Share Your Idea"

en src/config/index.js
if (proccess.env.NODE_ENV !== "production"){
    require("dotenv").config();
}

module.exports={
    PORT: process.env.PORT,
    MONGO_URI: proccess.env.MONGO_URI,
    APPLICATION_NAME: proccess.env.APPLICATION_NAME
}

en src/startup/container.js
const { createContainer, asClass, asValue, asFunction } =require('awilix');// asclasss/value/funtion inyecta un objeto como una clase, valor o funcion

const container= createContainer();

module.exports= container;

en src/services/home.service.js
    class HomeServive{
        index(){
        return{
            message:"hello world"
        };
        }
    }

    module.exports = HomeServive;

en src/services/index.js
    module.exports = {
        HomeService: require("./home.service")
    }

en src/startup/container.js

    const { createContainer, asClass, asValue, asFunction } = require('awilix');// asclasss/value/funtion inyecta un objeto como una clase, valor o funcion

    //Services
    const { HomeService } = require('../services')

    const container= createContainer();

    container.register({
        HomeService: asClass(HomeService).singleton()
    });

    module.exports = container;


en controllers/home.controller.js:
    let _homeService = null;

    class HomeController{
        constructor ({HomeService}){
            _homeService = HomeService;
        }
        index(req, res){
            return res.send(_homeService.index())
        }

    }

    module.exports = HomeController;

importamos en controllers/index.js:
module.exports = {
    HomeController: require('./home.controller')
}

en startup/container.js:
    const { createContainer, asClass, asValue, asFunction } = require('awilix');// asclasss/value/funtion inyecta un objeto como una clase, valor o funcion
    //Services
    const { HomeService } = require('../services')
    //controller
    const { HomeController } =require('../controllers')

    const container= createContainer();
    container.register({
        HomeService: asClass(HomeService).singleton()
    }).register({
        HomeController: asClass(HomeController.bind(HomeController)).singleton()
    });

    module.exports = container;

en routes/index.routes.js:
    module.exports = {
        HomeRoutes: require('./home.routes')
    }

en routes/home.routes.js:
    const { Router } = require('express');
    module.exports = function({HomeController}){
        const router = Router();
        router.get("/", HomeController.index);
        return router;
    };

en startup/container.js agregamos:
    //routes
    const { HomeRoutes } = require('../routes/index.routes');
    y un nuevo registro en la variable container
    .register({
        HomeRoutes: asFunction(HomeRoutes).singleton()
    });

en routes/index.js:
const express = require('express');
const cors = require('cors');
const helmet = require('helmet');
const compression = require('compression');
require("express-async-errors");

module.exports = function({HomeRoutes}){
    const router = express.Router();
    const apiRoutes = express.Router();

    apiRoutes.use(express.json()).use(cors()).use(helmet()).use(compression());
    apiRoutes.use("/home", HomeRoutes);
    router.use("/v1/api", apiRoutes);

    return router
};

en startup/container.js:
en el apartado de //routes
const Routes = require('../routes');

//config
    const config = require('../config');

    agregamos otro registro:
    .register({
        router: asFunction(Routes).singleton(),
        config: asValue(config)
    })

    en startup/index.js:
    const express = require('express');

    let _express = null;
    let _config = null;

    class Server{
        constructor({config, router}){
            _config= config;
            _express = express().use(router);
        }

        start(){
            return new Promise(resolve => {
                _express.listen(_config.PORT, ()=>{
                    console.log(_config.APPLICATION_NAME + "API running on port" + _config.PORT);
                    resolve();
                });
            });
        }
    }

    module.exports = Server;

en startup/container:
    en el apartado de //config
    const app = require('.');
    y agregamos en el registro donde tenemos los atributos de router, config uno nuevo:
    app: asClass(app).singleton()

en index.js principal:
const container = require('./src/startup/container');
const server = container.resolve("app");
const { MONGO_URI } = container.resolve("config");

const mongoose = require('mongoose');
mongoose.set("useCreateIndex", true);

mongoose
.connect(MONGO_URI, { useNewUrlParser: true, useFindAndModify: false, useUnifiedTopology: true})
.then(()=>server.start())
.catch(console.log);

Arreglar error de rutas no encontradas y errores:
en src/middlewares:
    /not-found.middleware.js:
    module.exports = (req, res, next) => res.status(404).send({status:404, message:"Resource not found"});
    /error.middlewares.js:
    module.exports = (err, req, res, next) => {
        const httpStatus = err.status || 500;
    
        return res.status(httpStatus).send({
            status: httpStatus,
            message: err.message || "Internal server error"
        });
    };

    en middlewares.index.js
    module.exports = {
        NotFoundMiddleware: require("./not-found.middleware"),
        ErrorMiddleware: require("./error.middleware")
    }

    en routes/index.js:
    importamos:
    const { NotFoundMiddleware, ErrorMiddleware } = require('../middlewares');
    y agregamos abajo de las rutas establecidas:
    router.use(NotFoundMiddleware);
    router.use(ErrorMiddleware);

luego se hace commit y pull en el branch principal
----------------------------------------------------------------------------------------------------

Creacion de modelos:
en models
user.models.js:
    const mongoose = require('mongoose');
    const { Schema } = mongoose;
    const { compareSync, hashSync, genSaltSync } = require("bcryptjs");

    const UserSchema = new Schema({
        name: {type: String, required:true},
        username: {type: String, required:true},
        password: { type: String, required: true},
        age: {type: Number, required:true}
    });

    UserSchema.methods.toJSON = function(){
        let user = this.toObjetc();
        delete user.password;
        return user;
    };

    UserSchema.methods.comparePassword = function (){
        return compareSync(password, this.password);
    };

    UserSchema.pre('save', async function(next){
        const user = this;

        if(!user.isModified("password")){
            return next();
        }

        const salt = genSaltSync(10);//10 => es la longitud de 10 caracteres
        const hashedPassword = hashSync(user.password, salt);
        user.password = hashedPassword;
        next();
    });


    module.exports = mongoose.model("user", UserSchema);

en idea.model.js:
    const mongoose = require('mongoose');
    const { Schema } = mongoose;

    const IdeaSchema = new Schema({
        idea: {type: String, required:true},
        description: {type: String},
        upvotes:[{type: Boolean}],
        downvotes: [{type: Boolean}],
        author: {type: Schema.Types.ObjectId, ref: "user", required:true, autopopulate: true}, 
        comments:[{type: Schema.Types.ObjectId, ref: "comment", required:true, autopopulate: true}]
    });

    IdeaSchema.plugin(require('mongoose-autopopulate'));

    module.exports = mongoose.model("idea", IdeaSchema);

en comment.model.js:
    const mongoose = require('mongoose');
    const { Schema } = mongoose;

    const CommentSchema = new Schema({
        comment: {type: String, required:true},
        description: {type: String},
        author: {type: Schema.Types.ObjectId, ref: "user", required:true, autopopulate: true}
    });

    CommentSchema.plugin(require('mongoose-autopopulate'));

    module.exports = mongoose.model("comment", CommentSchema);

en models/index.js:
    module.exports = {
        User: require('./user.model'),
        Idea: require('./idea.model'),
        Comment: require('./comment.model')
    }

en startup/container.js
Importamos los modelos:
//models
const {User, Comment, Idea} = require('../models');

Agregamos el registro para nuestros modelos:
.register({
    User: asValue(User),
    Comment: asValue(Comment),
    Idea: asValue(Idea)
});

----------------------------------------------------------------------------------------------------
Creacion de repositorio:
creamos en repositories:
base.repository.js:
class BaseRepository {
    constructor(model){
        this.model = model;
    }

    async get(id){
        return await this.model.findById(id);
    }
    async getAll(){
        return await this.model.find();
    }
    async create(entity){
        return await this.model.create(entity);
    }
    async update(id, entity){
        return await this.model.findByIdAndUpdate(id, entity, {new: true});
    }
    async delete(id){
        return await this.model.findByIdAndDelete(id);
    }
}

module.exports = BaseRepository;

/user.repository.js:
const BaseRepository = require('./base.repository');
let _user = null;

class UserRepository extends BaseRepository {
    constructor({ User }){
        super(User);
        _user = User;
    }
    async getUserByUserName(userName){
        return await _user.findOne({userName});
    }

}

module.exports = UserRepository;

/idea.repository.js:
const BaseRepository = require('./base.repository');
let _idea = null;

class IdeaRepository extends BaseRepository {
    constructor({ Idea }){
        super(Idea);
        _idea = Idea;
    }

    async getUserIdea(author){
        return await _idea.find([author]);
    }
}

module.exports = IdeaRepository;

/comment.repository.js:
const BaseRepository = require('./base.repository');
let _comment= null;

class CommentRepository extends BaseRepository {
    constructor({ Comment }){
        super(Comment);
        _comment = Comment;
    }
}

module.exports = CommentRepository;

en repositories/index.js:
module.exports = {
    UserRepository: require('./user.repository'),
    IdeaRepository: require('./idea.repository'),
    CommentRepository: require('./comment.repository')
}

en el contenedor /startup/container.js:
importamos los repositorios:
//Repositories
const {CommentRepository, IdeaRepository, UserRepository} = require('../repositories');
y agregamos los registros:
.register({
    CommentRepository: asClass(CommentRepository).singleton(), 
    IdeaRepository: asClass(IdeaRepository).singleton(),
    UserRepository: asClass(UserRepository).singleton()
});
[ADD] Repositories added
-----------------------------------------------------------------------------------------------------

Creacion de microservicios:

en service/base.service.js:
    class BaseService{
        constructor(repository){
            this.repository = repository;
        }
        async get(id){
            if(!id){
                const error = new Error();
                error.status = 404;
                error.message = "id must be sent";
                throw error;
            }
            
            const currentEntity = await this.repository.get(id);
            if(!currentEntity){
                const error = new Error();
                error.status = 404;
                error.message = "entity does not found";
                throw error;
            }
        }
        
        async getAll(){
            return await this.repository.getAll();
        }

        async create(entity){
            return await this.repository.create(entity);
        }

        async update(id, entity){
            if(!id){
                const error = new Error();
                error.status = 404;
                error.message = "id must be sent";
                throw error;
            }
            return await this.repository.update(id, entity);
        }

        async delete(id){
            if(!id){
                const error = new Error();
                error.status = 404;
                error.message = "id must be sent";
                throw error;
            }
            return await this.repository.delete(id, entity);
        }
    }

    module.exports = BaseService;

en user.service.js:
    const BaseService = require('./base.service');
    let _userRepository = null;

    class UserService extends BaseService{
        constructor({UserRepository}){
            super(UserRepository);
            _userRepository = UserRepository;
        }

        async getUserByUserName(userName){
            return await _userRepository.getUserByUserName(userName);
        }
    }

    module.exports = UserService;

en idea.service.js:
    const BaseService = require('./base.service');
    let _ideaRepository = null;

    class IdeaService extends BaseService{
        constructor({IdeaRepository}){
            super(IdeaRepository);
            _ideaRepository = IdeaRepository;
        }

        async getUserIdea(author){
            if(!author){
                const error = new Error();
                error.status = 400;
                error.message = "UserId must be sent";
                throw error;
            }
            return await _ideaRepository.getUserIdea(author);
        }

        async upvoteIdea(ideaId){
            if(!ideaId){
                const error = new Error();
                error.status = 400;
                error.message = "IdeaId must be sent";
                throw error;
            }

            const idea = await _ideaRepository.get(ideaId);
            if (!idea){
                const error = new Error();
                error.status = 404;
                error.message = "idea does not exist";
                throw error;
            }

            idea.upvotes.push(true);

            return await _ideaRepository.update(ideaId, {upvotes: idea.upvotes});
        }

        async downvoteIdea(ideaId){
            if(!ideaId){
                const error = new Error();
                error.status = 400;
                error.message = "IdeaId must be sent";
                throw error;
            }

            const idea = await _ideaRepository.get(ideaId);
            if (!idea){
                const error = new Error();
                error.status = 404;
                error.message = "idea does not exist";
                throw error;
            }

            idea.downvotes.push(true);
            
            return await _ideaRepository.update(ideaId, {upvotes: idea.downvotes});
        }
    }

    module.exports = IdeaService;

en comment.service.js:
    const BaseService = require('./base.service');
    let _commentRepository = null;
    let _ideaRepository = null;

    class CommentService extends BaseService{
        constructor({CommentRepository, IdeaRepository}){
            super(CommentRepository);
            _commentRepository = CommentRepository;
            _ideaRepository = IdeaRepository;
        }

        async getIdeaComment(ideaId){
            if (ideaId){
                const error = new Error();
                error.status = 400;
                error.message = "ideaId must be sent";
                throw error;
            }
            const idea = await _ideaRepository.get(ideaId);
            if (!idea){
                const error = new Error();
                error.status = 404;
                error.message = "idea does not exist";
                throw error;
            }

            const { comments } = idea;
            return comments;
        }

        async createComment(commnent, ideaId){
            if (ideaId){
                const error = new Error();
                error.status = 400;
                error.message = "ideaId must be sent";
                throw error;
            }
            const idea = await _ideaRepository.get(ideaId);
            if (!idea){
                const error = new Error();
                error.status = 404;
                error.message = "idea does not exist";
                throw error;
            }

            const createdComment = await _commentRepository.create(commnent);
            idea.comments.push(createdComment); 

            return await _ideaRepository.update(ideaId, {comments: idea.comments});
        }
    }

    module.exports = CommentService;

en service/index.js:
    module.exports = {
        HomeService: require("./home.service"),
        UserService: require('./user.service'),
        IdeaService: require('./idea.service'),
        CommentService: require('./comment.service')
    }

en el contenedor:
importamos donde ya teniamos el sevicio de home:
    UserService, IdeaService, CommentService

    Agregamos los registros de los servicios donde ya teniamos el sevicio de homeService:
    UserService: asClass(UserService).singleton(), 
    IdeaService: asClass(IdeaService).singleton(), 
    CommentService: asClass(CommentService).singleton() 
-----------------------------------------------------------------------------------------------------

Creacion de los controladores:
en user.controller.js:
    let _userService = null;

    class UserController{
        constructor({UserService}){
            _userService = UserService
        }

        async get(req, res){
            const { userId } = req.params;
            const user = await _userService.get(userId);
            return res.send(user);
        }

        async getAll(req, res){
            const users = await _userService.getAll();
            return res.send(users);
        }

        async update(req, res){
            const { body } = req;
            const { userId } = req.params;
            const  updateUser =  await _userService.update(userId, body);
            return res.send(updateUser);
        }

        async delete(req, res){
            const { userId } = req.params;
            const deleteUser = await _userService.delete(userId);
            return res.send(deleteUser);
        }
    }

    module.exports = UserController;

en idea.controller.js:
    let _ideaService = null;

    class IdeaController{
        constructor({IdeaService}){
            _ideaService = IdeaService
        }

        async get(req, res){
            const { ideaId } = req.params;
            const idea = await _ideaService.get(ideaId);
            return res.send(idea);
        }

        async getAll(req, res){
            const ideas = await _ideaService.getAll();
            return res.send(ideas);
        }

        async create(req, res){
            const { body } = req;
            const createIdea = await _ideaService.create(body);
            return res.status(201).send(createIdea);
        }

        async update(req, res){
            const { body } = req;
            const { ideaId } = req.params;
            const  updateIdeas =  await _ideaService.update(ideaId, body);
            return res.send(updateIdeas);
        }

        async delete(req, res){
            const { ideaId } = req.params;
            const deleteIdeas = await _ideaService.delete(ideaId);
            return res.send(deleteIdeas);
        }

        async getUserIdeas(req, res){
            const {userId} = req.params;
            const ideas = await _ideaService.getUserIdeas(userId);
            return res.send(ideas);
        }

        async upvoteIdea(req, res){
            const {ideaId} = req.params;
            const idea = await _ideaService.upvoteIdea(ideaId);
            return res.send(idea);
        }

        async downvoteIdea(req, res){
            const {ideaId} = req.params;
            const idea = await _ideaService.downvoteIdea(ideaId);
            return res.send(idea);
        }
    }

    module.exports = IdeaController;

en comment.controller.js
    let _commentService = null;

    class CommentController{
        constructor({CommentService}){
            _commentService = CommentService
        }

        async get(req, res){
            const { commentId } = req.params;
            const comment = await _commentService.get(commentId);
            return res.send(comment);
        }

        async update(req, res){
            const { body } = req;
            const { commentId } = req.params;
            const  updateComment =  await _commentService.update(commentId, body);
            return res.send(updateComment);
        }

        async delete(req, res){
            const { commentId } = req.params;
            const deleteComment = await _commentService.delete(commentId);
            return res.send(deleteComment);
        }

        async getIdeaComment(req, res){
            const { ideaId } = req.params;
            const comments = await _commentService.getIdeaComment(ideaId);
            return res.send(comments);
        }

        async createComment(req, res){
            const { body } = req;
            const { ideaId } = req.params;
            const createComment = await _commentService.createComment(body, ideaId);
            return res.send(createComment);
        }
    }

    module.exports = CommentController;

en controller/index.js:
    module.exports = {
        HomeController: require('./home.controller'), 
        UserController: require('./user.controller'),
        IdeaController: require('./idea.controller'),
        CommentController: require('./comment.controller')
    }

en el container:
importamos en el apartado de controladores:
    UserController, IdeaController, CommentController

Agregamos los registros de los controladores:
    UserController: asClass(UserController.bind(UserController)).singleton(),
    IdeaController: asClass(IdeaController.bind(IdeaController)).singleton(),
    CommentController: asClass(CommentController.bind(CommentController)).singleton(),

[ADD] controllers added
---------------------------------------------------------------------------------------------------